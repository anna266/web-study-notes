[](https://juejin.cn/post/6844903614918459406)

**创建数组：**

1. 字面量方法： var a = [3,11,8]

2. 构造器： var a = Array(); //[]

   ​                 var a =  Array(3) // [ , , ]即数组从长度为3

   ​                 var a = Array(3,11,8) //[3,11,8]

   实际上 new Array === Array，加不加new没有影响

## 方法

### 1. 改变原数组（7个）

- ### **splice()** 

  想数组中添加/删除项目，然后返回被删除的项目

  array.splice(index,[howmany],[item1,...,itemN]) //[xxx]表示该项可选

1. index：规定添加/删除元素的位置，使用负数可从数组结尾处规定位置（0是第一个，-1是最后一个）
2. howmay： 表示从index处（包括index处）往后删除的元素个数，若为0表示不删除
3. intem1,...,itmeN表示向数组中添加的新元素

  **返回值**：若有元素被删除，返回的是**所删除元素构成的数组**，若没有删除元素，则返回空数组

- [x] 注意点：

1. 数组如果元素不够，会删除到最后一个元素为止
2. 操作的元素，包括开始的那个元素
3. 可以添加很多个元素
4. **添加是在开始的元素前面添加的**

- ### **sort()**

  对数组元素进行排序，并返回排序后的数组

  sort([比较函数])，参数可选，可以规定排序顺序

默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用`toString()`方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。

**比较函数的两个参数：**

sort的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素：

- 若比较函数返回值<0，那么a将排到b的前面;
- 若比较函数返回值=0，那么a 和 b 相对位置不变；
- 若比较函数返回值>0，那么b 排在a 将的前面；

依照该规则，可以设定出任意自己想要的排序效果

```
//升序
 var a = [10,1,3,4,20,4,25,8,63]
a.sort((x,y)=>{
	return x-y
})
//降序
a.sort((x,y)=>{
	return y-x
})
```

- ### pop()

删除一个数组中的最后一个元素，并返回这个元素，无参数

- ### shift()

删除数组中的第一个元素，并返回删除的这个元素

- ### push()

向数组末尾添加一个或多个元素，并返回新数组的长度

参数 item1, item2, ..., itemN为要添加到数组末尾的元素

- ### unshift()

向数组开头添加一个或多个元素，并返回新数组的长度

参数 item1, item2, ..., itemN为要添加到数组开头的元素

- ### reverse()

作用：用于颠倒数组元素的顺序，无参数



### 2. 不改变原数组（8个）

- ### slice()

该方法返回一个从开始到结束（不包括结束）选择的数组的一部分**浅拷贝**到一个新的数组对象，且原数组不会被修改。

```
语法： array.slice([begin], [end])
```

begin(可选): 索引数值,接受负值，从该索引处开始提取原数组中的元素,**默认值**为0。

end(可选):索引数值(不包括),接受负值，在该索引处前结束提取原数组元素，**默认值**为数组末尾(包括最后一个元素)。该参数在某些时候也可看做截取的元素个数

- ### join()

作用：**数组转字符串**

把数组中的所有元素通过指定的分隔符放入一个字符串中，返回生成的字符串

```
语法：arr.join(str)

    let a= ['hello','world'];
    let str=a.join(); // 'hello,world'
    let str2=a.join('+'); // 'hello+world'
```

参数str可选，指定多个元素拼接字符串的分隔符，默认为逗号

注意： 调用join()/toString()时，若数组中有元素为数组，里面的数组也会调用join()/toString()，若有元素为对象，则会被转换为[object,object]字符串

- ### toLocalString()

作用：**数组转为本地字符串**

返回一个表示数组元素的字符串，数组中的每个元素均执行**toLocalString()**后，在由join()方法将其拼接为以逗号分隔的字符串

```
语法: array.toLocalString()

    let a=[{name:'OBKoro1'},23,'abcd',new Date()];
    let str=a.toLocaleString(); // [object Object],23,abcd,2018/5/28 下午1:52:20 
```

无参数

- ### toString()

作用：数组转字符串

与join()方法类似，只是该方法只能用逗号分隔符来连接，没有参数

**值得注意的是**：当数组和字符串操作的时候，js 会调用这个方法将数组自动转换成字符串

```
   let b= [ 'toString','演示'].toString(); // toString,演示
   let a= ['调用toString','连接在我后面']+'啦啦啦'; // 调用toString,连接在我后面啦啦啦
```

- ### concat()

作用：用于合并两个或多个数组，返回一个拼接后的新数组

```
语法： var newArray = oldArray.concat(array1,array2,...arrayn)
```

参数：必须，其可以是任意多个具体的值，或是任意多个数组

注意：  // 合并嵌套数组  会**浅拷贝**嵌套数组

```
   let d = [1,2 ];
   let f = [3,[4]];
   let newVal4 = d.concat(f); // [1,2,3,[4]]
```

**值得一提的是**，ES6中使用扩展运算符可以达到相同的效果

```
    let a = [2, 3, 4, 5]
    let b = [ 4,...a, 4, 4]
    console.log(a,b); //  [2, 3, 4, 5] [4,2,3,4,5,4,4]
```

- ### indexOf()

作用：返回在数组中找到第一个对应元素的索引值，若不存在，则返回-1 【一律从前往后找】

```
语法： array.indexOf(searchElement,fromIndex)
```

参数：

searchElement(必须):被查找的元素

fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。(负值将会从后往前找到该项，并从该项从前往后开始查找)

数组的indexOf搜索与字符串的indexOf不一样，数组的indexOf使用严格相等===，数组元素要完全匹配才能搜索成功

**注意**：indexOf()不能识别`NaN`

```
    let a=['啦啦',2,4,24,NaN]
    console.log(a.indexOf('啦'));  // -1 
    console.log(a.indexOf('NaN'));  // -1 
    console.log(a.indexOf('啦啦')); // 0
```

- ### lastIndexOf()

作用：返回在数组中找到的最后一个位置的索引值，若不存在，则返回-1【一律从后往前找】

```
语法： arr.lsatIndexOf(searchElement,fromIndex)
```

参数：

searchElement(必须): 被查找的元素

fromIndex(可选): 逆向查找开始位置，默认值为-1，即从数组最后一个位置开始向前查找

关于fromIndex有三个规则:

1. 正值。如果该值大于或等于数组的长度，则整个数组会被查找。
2. 负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)
3. 负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。

```
 let a=['OB',4,'Koro1',1,2,'Koro1',3,4,5,'Koro1']; // 数组长度为10
 // let b=a.lastIndexOf('Koro1',4); // 从下标4开始往前找 返回下标2
 // let b=a.lastIndexOf('Koro1',100); //  大于或数组的长度 查找整个数组 返回9
 // let b=a.lastIndexOf('Koro1',-11); // -1 数组不会被查找
 let b=a.lastIndexOf('Koro1',-9); // 从第二个元素4往前查找，没有找到 返回-1
```



### **3. 数组的遍历方法**

该数组遍历语法均遵循以下原则：

```
    1. 对于空数组是不会执行回调函数的
    2. 对于已在迭代过程中删除的元素，或者空元素会跳过回调函数
    3. 遍历次数再第一次循环前就会确定，再添加到数组中的元素不会被遍历。
    4. 如果已经存在的值被改变，则传递给 callback 的值是遍历到他们那一刻的值。
```

- ### forEach()

作用：给数组中的每一项进行一次回调

```
语法： array.forEach(function(currentValue,index,arr),thisValue)
```

参数：

function(必须): 数组中每个元素需要调用的函数。

1. currentValue(必须),数组当前元素的值    
2. index(可选), 当前元素的索引值    
3.  arr(可选),数组对象本身

thisValue(可选): 当执行回调函数时**this绑定对象的值**，默认值为`undefined`

**注意：**

- 无法中途退出循环，只能用`return`退出本次回调，进行下一次回调（无法使用break结束整个循环，因为无法中途退出）

- 它总是返回 undefined值，即使你return了一个值（该**遍历函数返回值为undefined**）

举例：

```
    let a = [1, 2, ,3]; // 最后第二个元素是空的，不会遍历(undefined、null会遍历)
    let obj = { name: 'OBKoro1' };
    let result = a.forEach(function (value, index, array) { 
      a[3] = '改变元素';
      a.push('添加到尾端，不会被遍历')  //遍历一开始次数就已经确定，不会遍历新加上的数据，
      console.log(value, 'forEach传递的第一个参数'); // 分别打印 1 ,2 ,改变元素
      console.log(this.name); // OBKoro1 打印三次 this绑定在obj对象上
      // break; // break会报错
      return value; // return只能结束本次回调 会执行下次回调
      console.log('不会执行，因为return 会执行下一次循环回调')
    }, obj);
    console.log(result); // 即使return了一个值,也还是返回undefined
    // 回调函数也接受接头函数写法
```

- ### every()

作用：检测数组中所有元素是否都符合函数定义的条件

```
语法： array.every(function(currentValue,index,arr),thisValue)
```

参数：与forEach类似

方法返回值规则：

1. 如果数组中检测到**有一个元素不满足，则整个表达式返回 false**，且剩余的元素不会再进行检测
2. 如果所有元素**都满足条件，则返回 true**

```
    function isBigEnough(element, index, array) { 
      return element >= 10; // 判断数组中的所有元素是否都大于10
    }
    let result = [12, 5, 8, 130, 44].every(isBigEnough);   // false
    let result = [12, 54, 18, 130, 44].every(isBigEnough); // true
    // 接受箭头函数写法 
    [12, 5, 8, 130, 44].every(x => x >= 10); // false
    [12, 54, 18, 130, 44].every(x => x >= 10); // true
```

- ### some

作用：找出数组中是否有满足条件的元素

```
语法： array.some(function(currentValue,index,arr),thisValue)
```

参数：与forEach类似

方法返回值规则：

1. 如果**有一个元素满足条件，则表达式返回true**, 剩余的元素不会再执行检测
2. 如果**没有满足条件的元素，则返回false**

```
 function isBigEnough(element, index, array) {
   return (element >= 10); //数组中是否有一个元素大于 10
 }
 let result = [2, 5, 8, 1, 4].some(isBigEnough); // false
 let result = [12, 5, 8, 1, 4].some(isBigEnough); // true
```

- ### filter

作用：返回一个新数组，其包通过函数测试的所有元素

```
语法： array.fliter(function(currentValue,index,arr),thisValue)
```

参数：与forEach类似

```
     let a = [32, 33, 16, 40];
    let result = a.filter(function (currentValue, index, array) {
      return value >= 18; // 返回a数组中所有大于18的元素
    });
    console.log(result,a);// [32,33,40] [32,33,16,40]
```

- ### map

作用：返回一个新数组，该新数组由数组中每个元素进行操作后的结果所构成

```
语法： array.map(function(currentValue,index,array),thisValue)
```

参数：与forEach类似

```
let a = ['1','2','3','4'];
let result = a.map(function (value, index, array) {
  return value + '新数组的新元素'
});
console.log(result, a); 
// ["1新数组的新元素","2新数组的新元素","3新数组的新元素","4新数组的新元素"] ["1","2","3","4"]
```

- ### reduce

作用：为数组提供累加器，合并为一个值，对累加器和数组中的每个元素（从左到右）应用一个函数，最终合并为一个值。

```
语法： array.reduce(function(total,currentValue,index,arr),initialValue)
```

参数：

function(必须): 数组中每个元素需要调用的函数。

    // 回调函数的参数
    1. total(必须)，初始值, 或者上一次调用回调返回的值
    2. currentValue(必须),数组当前元素的值
    3. index(可选), 当前元素的索引值
    4. arr(可选),数组对象本身
initialValue(可选): 指定第一次回调 的第一个参数。

回调第一次执行时：

- 如果 initialValue 在调用 reduce 时被提供，那么第一个 total 将等于 initialValue，此时 currentValue 等于数组中的第一个值；
- 如果 initialValue 未被提供，那么 total 等于数组中的第一个值，currentValue 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。
- 如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么回调不会被执行，数组的唯一值将被返回。

    // 数组求和 
    let sum = [0, 1, 2, 3].reduce(function (a, b) {
      return a + b;
    }, 0);
    // 6
    // 将二维数组转化为一维 将数组元素展开
    let flattened = [[0, 1], [2, 3], [4, 5]].reduce(
      (a, b) => a.concat(b),
      []
    );
     // [0, 1, 2, 3, 4, 5]
- ### reduceRight 

这个方法除了与reduce执行方向相反外，其他完全与其一致。



## ES6相关

**1. Array.of()**

返回由参数值组成的数组

```
let a = Array.of(3) // [3],此处可以区分与上面Array(3)的区别
let a = Array.of(3,11,8) //[3,11,8]
```

**2. Array.from()**

将两类对象转换为真正的数组



### 不改变原数组

- ### copyWithin()